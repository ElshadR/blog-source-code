:imagesdir: images

= Moving from SQL Server to Couchbase Part 2: Data Migration

In this series of blog posts, I'm going to lay out the considerations when moving to a document database when you have a relational background. Specifically, Microsoft SQL Server as compared to  link:http://developer.couchbase.com/?utm_source=blogs&utm_medium=link&utm_campaign=blogs[Couchbase Server].

In three parts, I'm going to cover:

* link:https://blog.couchbase.com/2017/february/moving-from-sql-server-to-couchbase-part-1-data-modeling[Data modeling]
* The data itself (this blog post)
* Applications using the data

The goal is to lay down some general guidelines that you can apply to your application planning and design.

If you would like to follow along, I've created an application that demonstrates Couchbase and SQL Server side-by-side. link:https://github.com/couchbaselabs/blog-source-code/tree/master/Groves/045MigrateFromSQLServer1/src[Get the source code from GitHub], and make sure to link:https://couchbase.com/downloads?utm_source=blogs&utm_medium=link&utm_campaign=blogs[download a developer preview of Couchbase Server].

== Data Types in JSON vs SQL

Couchbase (and many other document databases) use JSON objects for data. JSON is a powerful, human readable format to store data. When comparing to data types in relational tables, there are some similarities, and there are some important differences.

All JSON data is made up of 6 types: string, number, boolean, array, object, and null. There are a lot of link:https://msdn.microsoft.com/en-us/library/ms187752(v=sql.110).aspx[data types available in SQL Server]. Let's start with a table that is a kind of "literal" translation, and work from there.

[width="100%",options="header"]
|====================
| JSON | SQL Server 
| string | nvarchar, varchar, text
| number | int, float, decimal, double
| boolean | bit
| null | null
| array / object | JSON/XML fields
|====================

It's important to understand how JSON works. I've listed some high-level differences between JSON data types of SQL Server data types. Assuming you already understand SQL data types, you might want to link:http://json.org/[spend some time learning more about JSON and JSON data types].

*string* in SQL Server is often defined by a length. _nvarchar(50)_ or _nvarchar(MAX)_ for instance. In JSON, you don't need to define a length. Just use a string.

*number* in SQL Server varies widely based on what you are using it for. The *number* type in JSON is flexible, in that it can store integers, decimal, or floating point. In specialized circumstances, like if you need a specific precision or you need to store very large numbers, you may want to store a number as a string instead.

*boolean* in JSON is true/false. In SQL Server, it's roughly equivalent: a bit that represents true/false.

In JSON, any value can be *null*. In SQL Server, you set this on a field-by-field basis. If a field in SQL Server is not set to "nullable", then it will be enforced. In a JSON document, there is no such enforcement.

JSON has no *date* data type. Often dates are stored as UNIX timestamps, but you could also use string representations or other formats for dates. link:https://developer.couchbase.com/documentation/server/current/n1ql/n1ql-language-reference/datefun.html[The N1QL query language has a variety of date functions available].

In SQL Server, there is a *geography* data type. In Couchbase, link:https://developer.couchbase.com/documentation/server/current/indexes/querying-using-spatial-views.html[the GeoJSON format is supported].

There are some other specialized data types in SQL Server, including hierarchyid, and xml. Typically, these would be unrolled in JSON objects and/or referenced by key (as explored in link:https://blog.couchbase.com/2017/february/moving-from-sql-server-to-couchbase-part-1-data-modeling[part 1 of this blog series on data modeling]). You can still store XML/JSON within a string if you want, but if you do, then you can't use the full power of N1QL on those fields.

== Migrating and translating data

After you've designed your model with link:https://blog.couchbase.com/2017/february/moving-from-sql-server-to-couchbase-part-1-data-modeling[part 1 on data modeling], you can use the above guide to start moving data over to Couchbase.

For a naive migration (1 row to 1 document), you can write a very simple program to loop through the tables, columns, and values of a relational database and spit out corresponding documents. A tool like link:https://github.com/StackExchange/dapper-dot-net[Dapper] would handle all the data type translations within C# and feed them into the link:https://developer.couchbase.com/documentation/server/current/sdk/dotnet/start-using-sdk.html?utm_source=blogs&utm_medium=link&utm_campaign=blogs[Couchbase .NET SDK].

You could also try using a link:https://developer.couchbase.com/documentation/server/current/connectors/talend/talend.html?utm_source=blogs&utm_medium=link&utm_campaign=blogs[Talend connector] to connect Couchbase to SQL Server (or other relational databases).

Completely flat data is relatively uncommon, so for more complex models, you will probably need to write code to migrate from the old relational model to the new document model.

Here are some things you want to keep in mind when writing migration code (of any kind, but especially relational-to-nonrelational):

* *Give yourself plenty of time in planning.* While migrating, you may discover that you need to rethink your model. You will need to test and make adjustments, and it's better to have extra time than make mistakes while hurrying.
* *Test your migration using real data.* Data can be full of surprises. You may think that NVARCHAR field only ever contains string representations of numbers, but maybe there are some abnormal rows that contain words. Use a copy of the real data to test and verify your migration.
* *Be prepared to run the migration multiple times.* Have a plan to rollback a failed migration and start over. This might be a simple `DELETE FROM bucket` in N1QL, or it could be a more nuanaced and targeted series of cleanups. If you plan from the start, this will be easier.
* *ETL or ELT?* Extract-Transform-Load, or Extract-Load-Transform. When are you going to do a transform? When putting data into Couchbase, the flexibility of JSON allows you to transfer-in-place _after_ loading if you choose.

=== An example ETL migration

I wrote a very simple migration console app using C#, Entity Framework, and the Couchbase .NET SDK. It migrates both the shopping cart and the social media examples from the previous blog post. The full https://github.com/couchbaselabs/blog-source-code/tree/master/Groves/045MigrateFromSQLServer1/src[source code is available on GitHub].

This app is going to do the transformation, so this is an ETL approach. When the data gets into Couchbase, it will already be transformed.

I created a `ShoppingCartMigrator` class and a `SocialMediaMigrator` class. I'm only going to cover the shopping cart in this post. I pass it a Couchbase `bucket` and the Entity Framework context that I used in the last blog post. (You could instead pass an NHibernate session or a plain `DbConnection` here, depending on your preference).

[source,C#,indent=0]
----
include::src/SQLServerToCouchbase/SQLServerToCouchbase.Migrate/ShoppingCartMigrator.cs[tag=ShoppingCartMigratorTop]
include::src/SQLServerToCouchbase/SQLServerToCouchbase.Migrate/ShoppingCartMigrator.cs[tag=ShoppingCartMigratorBottom]
----

With those objects in place, I created a `Go` method to perform the migration, and a `Rollback` method to delete any documents created in the migration, should I choose to.

For the `Go` method, I let Entity Framework do the hard work of the joins, and loop through every shopping cart.

[source,C#,indent=0]
----
include::src/SQLServerToCouchbase/SQLServerToCouchbase.Migrate/ShoppingCartMigrator.cs[tag=ShoppingCartMigratorGo]
----

I chose to abort the migration if there's even one error. You may not want to do that. You may want to log to a file instead, and address all the records that cause errors at once.

For the rollback, I elected to delete every document that has a type of "ShoppingCart".

[source,C#,indent=0]
----
include::src/SQLServerToCouchbase/SQLServerToCouchbase.Migrate/ShoppingCartMigrator.cs[tag=ShoppingCartMigratorRollback]
----

This is the simplest approach. A more complex approach could involve putting a temporary "fingerprint" marker field onto certain documents, and then deleting documents with a certain fingerprint in the rollback. (E.g. `DELETE FROM sqltocb WHERE fingerprint = '999cfbc3-186e-4219-ab5d-18ad130a9dc6'`). Or vice versa: fingerprint the problematic data for later analysis and delete the rest. Just make sure to cleanup these temporary fields when the migration is completed successfully.

When you try this out yourself, you may want to run the console application twice, just to see the rollback in action. The second attempt will result in errors because it will be attempting to create documents with duplicate keys.

== What about the other features of SQL Server?

Not everything in SQL Server has a direct counterpart in Couchbase. In some cases, it won't ever have a counterpart. In some cases, there will be a rough equivalent. Some features will arrive in the future, as Couchbase is under fast-paced, active, open-source development, and new features are being added when appropriate.

Also keep in mind that document databases and NoSQL databases often force business logic out of the database to a larger extent than relational databases. As nice as it would be if Couchbase Server had every feature under the sun, there are always tradeoffs. Some are technical in nature, some are product design decisions. Tradeoffs could be made to add relational-style features, but at some point in that journey, Couchbase stops being a fast, scalable database and starts being "just another" relational database. There is certainly a lot of convergence in both relational and non-relational databases, and a lot of change happening every year.

With that in mind, I'll cover some of the main SQL Server features you may be curious about, but keep in mind the date of this blog post. The feature you simply can't live without may have been added in the meantime. When in doubt, leave a comment, check on the link:https://forums.couchbase.co?utm_source=blogs&utm_medium=link&utm_campaign=blogs[Couchbase Forums], or contact me.

=== Autonumber

Couchbase Server does not currently offer any sort of automatic key generation or sequential key numbering.

However, you can link:https://developer.couchbase.com/documentation/server/current/sdk/core-operations.html[use the *Counter* feature] to do something similar. The idea is that a document is set aside as a special counter document. This document can be incremented as an atomic operation, and the number can be used as a partial or whole key of the new document being created.

=== SQL queries

Thanks to N1QL, migrating your SQL queries should not be very difficult. Your data model probably changed, and not every function in tSQL is (yet) available in N1QL. But for the most part, this shouldn't be difficult.

Back to the shopping cart, here's an example of a simple tSQL query that would get shopping cart information for a given user:

[source,SQL]
----
SELECT c.Id, c.DateCreated, c.[User], i.Price, i.Quantity
FROM ShoppingCart c
INNER JOIN ShoppingCartItems i ON i.ShoppingCartID = c.Id
WHERE c.[User] = 'mschuster'
----

In Couchbase, a shopping cart could be modeled as a single document, so a roughly equivalent query would be:

[source,SQL]
----
SELECT META(c).id, c.dateCreated, c.items, c.`user`
FROM `sqltocb` c
WHERE c.type = 'ShoppingCart'
AND c.`user` = 'mschuster';
----

(You could `UNNEST` the Items collection if you want to filter or sort individual items).

In many document databases othat than Couchbase, you would likely have to learn an API for creating queries, and you would not be able to apply your tSQL experience to help ramp up. I'm not saying that translation is always going to be a walk in the park, but it's going to be relatively easy compared to the alternatives. If you're starting a *new* project, then you'll be happy to know that your SQL-writing skills will continue to be put to good use!

=== SQL Server Views

In SQL server, you can store SELECT statements as Views. You can refer to them like tables, join with them, and so on.

The closest thing in Couchbase is also called link:https://developer.couchbase.com/documentation/server/current/indexes/querying-using-map-reduce-views.html?utm_source=blogs&utm_medium=link&utm_campaign=blogs[Views].

A view in Couchbase is defined as a Map/Reduce query using JavaScript. The JavaScript is saved to the cluster, and the results of the map/reduce are distributed evenly among the nodes. It is something like a link:https://msdn.microsoft.com/en-us/library/ms191432.aspx[materialized view in SQL Server]. The results of these views are updated automatically on an interval, and are also updated incrementally as documents are mutated. This means that, by default, the results of the views are *eventually* consistent with the actual documents. As a developer, you can link:https://developer.couchbase.com/documentation/server/current/architecture/querying-data-with-views.html?utm_source=blogs&utm_medium=link&utm_campaign=blogs[specify the level of consistency] (or staleness) you want. This will have an impact on performance.

=== SQL Stored Procedures

There is no equivalent of sprocs in Couchbase. If you don't already have a service tier, and you are using sprocs to share some logic across domains, I recommend that you create a service tier and move the logic there.

Typical tiers:

* Web tier (UI - Angular/React/Traditional ASP.NET MVC)
* Service tier (ASP.NET WebApi)
* Database

If you already have a service tier, move the sproc logic into that. If you don't have a service tier, create one. This will live between the database and the UI.

In the source code for this series, I've created a single stored procedure.

[source,SQL]
----
include::src/SQLServerToCouchbase/SQLServerDataAccess/Scripts/05Sproc.sql[]
----

This sproc can be executed from Entity Framework as follows:
 
[source,C#]
----
include::src/SQLServerToCouchbase/SQLServerDataAccess/SqlShoppingCartRepository.cs[tag=Sproc]
----

This is a very simple sproc, but it introduces a basic search functionality. The benefits to such a sproc:

* *Reusable* The same sproc can be reused between different applications
* *Abstraction* The sproc implementation can be changed or improved. In this case, a basic `LIKE` could be switched out for a more robust full text search.

Any approach taken with introducing a service tier should provide the same benefits. I created an ASP.NET WebApi endpoint to take the place of the sproc.

[source,C#]
----
include::src/SQLServerToCouchbase/SQLServerToCouchbase.Web/Controllers/ServiceController.cs[tag=service]
----

_Note: for the sake of simplicity in the sample code, this endpoint actually lives in the same web project, but in production, it should be moved to its own project and deployed separately._

This endpoint holds a N1QL query that is similar in nature to the above sproc. Let's see if it holds up to the same benefits:

* *Reusable?* Yes. This endpoint can be deployed to its own server and be reused from other applications.
* *Abstraction?* Again, yes. The implementation uses the naive `LIKE` approach, which we could improve by switching it to use link:https://developer.couchbase.com/documentation/server/current/sdk/dotnet/full-text-searching-with-sdk.html[Couchbase's Full Text Search features] without changing the API.

Instead of calling a sproc through Entity Framework, this endpoint would be called via HTTP. Here's an example that uses the RestSharp library:

[source,C#]
----
include::src/SQLServerToCouchbase/CouchbaseServerDataAccess/CouchbaseShoppingCartRepository.cs[tag=SearchForCartsByUserName]
----

If you are building a new project, I recommend that you create a service tier with the expectation of it being used across your enterprise. This allows you to have the same "shared code" that sprocs would normally provide without putting that code into the database.

This is also true for SQL Server *functions, user defined types, rules, user-defined CLR objects*.

_Note: the above sproc example is a `SELECT` just to keep the example simple. In this case, you could potentially create a MapReduce View instead. A MapReduce view cannot mutate documents though, so a service tier approach is a better general solution to replacing sprocs._

=== SQL Triggers

If sprocs weren't already controversial enough, just bring up triggers in a conversation. As with stored procedures, I generally recommend that you move the trigger logic into the service tier, away from the database. If your software project depends on a lot of triggers, or complex triggers, or a lot of complex triggers, then you might want to wait or find another project to try using Couchbase Server in.

That being said, there is some cutting-edge stuff that is being worked on that might be roughly equivalent to triggers. If you are interested in this, please contact me, and also stay tuned to link:http://blog.couchbase.com[the Couchbase Blog] for the latest information.

=== Security

Couchbase has link:https://developer.couchbase.com/documentation/server/current/security/concepts-rba.html?utm_source=blogs&utm_medium=link&utm_campaign=blogs[role-based access control (RBAC)] for administrators.

Couchbase can integrate with LDAP to manage Couchbase administrators and assign roles to users. Couchbase can also create read-only users internally.

There are some more robust changes and improvements coming to the Couchbase RBAC system, so stay tuned. In fact, I would recommend that you start link:https://blog.couchbase.com/2017/january/introducing-developer-builds[checking out the monthly developer builds], as I expect to see some interesting improvements and features in this area soon!

== Summary

This blog post compared and contrasted the data features available in Couchbase Server with SQL Server. If you are currently using SQL Server and are considering adding a document database to your project or starting a new project, I am here to help. Please contact me at link:mailto:matthew.groves@couchbase.com[matthew.groves@couchbase.com], ask a question on link:https://forums.couchbase.com/?utm_source=blogs&utm_medium=link&utm_campaign=blogs[the Couchbase Forums], or ping me on https://twitter.com/mgroves[Twitter @mgroves].