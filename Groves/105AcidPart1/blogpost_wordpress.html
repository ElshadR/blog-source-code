
<div class="paragraph">
<p>ACID properties are a topic that I get asked about a lot. Generally, people ask in the context of transactions: "Are there NoSQL transactions?", "Can I use ACID transactions in Couchbase?", and so on. But today&#8217;s distributed applications do not always expect or need all of the ACID properties from their database. I&#8217;ll dig deeper into the ACID properties in this post.</p>
</div>
<div class="sect1">
<h2 id="_couchbase_and_transactions">Couchbase and Transactions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Scaling, performance, and flexibility have been the core focus of the Couchbase data platform, and distributed, multi-document transactions are often at odds with these characteristics.</p>
</div>
<div class="paragraph">
<p>Part 1 of this 2-part blog post is going to cover the building blocks of ACID that <strong>are</strong> available in Couchbase. You can use these "primitives" without sacrificing the overall scaling, performance, and flexibility of Couchbase. Depending on your use case, these primitives might be adequate on their own, or in concert with each other.</p>
</div>
<div class="paragraph">
<p>Currently, Couchbase supports single document transactions, but does not provide multi-document transaction support. But, in part 2 of this series, I will show an approach that uses these building blocks to make something <strong>like</strong> a multi-document transaction with Couchbase.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_what_are_the_acid_properties">What are the ACID properties?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>ACID stands for: Atomicity, Consistency, Isolation, Durability. It was coined in the 1980s, but has existed since the 1970s in traditional, non-distributed, relational databases. It describes a class of database that is capable of providing operations with safety guarantees.</p>
</div>
<div class="paragraph">
<p>Applications have evolved from monolithic to distributed micro-service based applications. Microservices still expect certain aspects of transactionality such as an atomic commit or rollback, but not necessarily full ACID behavior. The safety of full ACID behavior may still be important, but in modern web and mobile software, it is often lower priority to performance and scalability. However, it is not an "either/or" situation. Couchbase provides some tools and capabilities to help you balance safety and performance.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_a_is_for_atomicity">A is for Atomicity</h2>
<div class="sectionbody">
<div class="paragraph">
<p>"Atomicity" means that a group of operations either all succeed or all fail. Couchbase provides atomicity for a single document at a time. An operation to get or set a document either succeeds or fails. Compared to an RDBMS guarantee of <strong>multiple</strong> operations succeeding or failing together, this may not seem like much.</p>
</div>
<div class="paragraph">
<p>But consider that <a href="https://blog.couchbase.com/json-data-modeling-rdbms-users/">data modeling</a> is very different between document databases and RDBMS.</p>
</div>
<div class="paragraph">
<p>In a relational database, you typically <strong>normalize</strong> the data. So, for instance, to store a a shopping cart with 3 items, you would need:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>1 row in a ShoppingCart table</p>
</li>
<li>
<p>3 rows in a ShoppingCartItems table</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><span class="image"><img src="http://blog.couchbase.com/wp-content/uploads/2018/04/10501-shopping-cart-acid-properties.png" alt="Shopping Cart example for ACID properties"></span></p>
</div>
<div class="paragraph">
<p>If you want to create a shopping cart with 3 items, this requires four <code>INSERT</code> statements. So, you might need your relational database to treat those 4 statements atomically.</p>
</div>
<div class="paragraph">
<p>Now consider a document database. You would create a single shopping cart JSON document, which would itself contain 3 items.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight decode:true"><code class="language-JavaScript" data-lang="JavaScript">key cart::001
{
    "user": "Matthew Groves",
    "dateCreated": "2018-03-22T13:57:31.2311892-04:00",
    "items": [
        { "name": "widget", "price": 19.99, "quantity": 2},
        { "name": "sprocket", "price": 17.89, "quantity": 1},
        { "name": "doodad", "price": 20.99, "quantity": 5}
    ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Getting or setting this document is a single atomic operation in Couchbase.</p>
</div>
<div class="paragraph">
<p>If you can model your data like this, then you immediately reduce your need for a multi-operation transaction.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_c_is_for_consistency">C is for Consistency</h2>
<div class="sectionbody">
<div class="paragraph">
<p>"Consistency" means that any constraints in the database about the data remain consistent before and after an ACID operation. For instance, if an atomic set of operations fails, then the data remains consistent with what it was before the operation. Additionally, relational databases enforce constraints (like a table schema) on the data. You cannot insert 6 columns of data into a 5 column table, for instance.</p>
</div>
<div class="paragraph">
<p>The only schema that Couchbase needs is JSON. If you perform an insert operation with JSON, you must supply valid JSON (the Couchbase SDKs will typically handle this for you). Couchbase only enforces this at the document level. Couchbase cannot prevent you from using a different JSON schema from document to document. For instance, consider these two documents:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight decode:true"><code class="language-JavaScript" data-lang="JavaScript">key user::001
{
    "user": "Matthew Groves",
    "dateCreated": "2018-03-22T13:57:31.2311892-04:00"
}

key user::002
{
    "userName": "Matthew Groves",
    "the_date_created": "2018-03-22T13:57:31.2311892-04:00"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>A Couchbase bucket allows both of those documents. However, note that the field names are not consistent with each other. This means that there is more responsibility at the application level to ensure the documents have consistent naming.</p>
</div>
<div class="paragraph">
<p>Another constraint that Couchbase enforces is the key. Each document must have a unique key. If you try to insert another document with a key of "user::001", for instance, an error will occur. So if you need to enforce a unique constraint, using the document key is one way to achieve this.</p>
</div>
<div class="sect2">
<h3 id="_query_consistency">Query Consistency</h3>
<div class="paragraph">
<p>Finally, I want to mention <a href="https://blog.couchbase.com/new-to-couchbase-4-5-atplus/">index consistency</a>. Couchbase is able to index fields or combinations of fields in JSON documents (just as relational databases can index columns or combinations of columns). However, Couchbase updated indexes <strong>asynchronously</strong>. When executing a N1QL query (SQL for JSON) in Couchbase, the default behavior is "Not Bounded". This means that the query will not wait for Couchbase to update the index before returning results. So, hypothetically, if you create a new document and immediately run a query, that document might not be in the results.</p>
</div>
<div class="paragraph">
<p>Fortunately, there are two other options to tweak the consistency of queries: RequestPlus and AtPlus.</p>
</div>
<div class="paragraph">
<p><strong>RequestPlus</strong> is at the opposite end of the consistency spectrum. It will wait for any pending index updates before processing the query. The trade-off here is performance, of course. A RequestPlus query will possibly take longer to execute.</p>
</div>
<div class="paragraph">
<p><strong>AtPlus</strong> is in the middle. Instead of waiting for an entire index to complete, AtPlus will only wait for indexing of the documents you specify. This provides better performance, better consistency, but it requires more work (since you have to specify which documents to wait for).</p>
</div>
<div class="paragraph">
<p><em>Note: The "Consistency" in ACID is different than the "Consistency" in the <a href="https://developer.couchbase.com/documentation/server/current/concepts/data-management.html">CAP theorem</a>. Couchbase is a <strong>strongly consistent</strong> distributed database. This means that each document has a single correct document per cluster, and there cannot be a "conflicting" or "sibling" document with the same key elsewhere in the cluster. A strongly consistent database does <strong>not</strong> imply anything about transactions or ACID properties.</em></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_i_is_for_isolation">I is for Isolation</h2>
<div class="sectionbody">
<div class="paragraph">
<p>"Isolation" is the ability for an operation to occur only after another operation on the same data has been completed. In this way, each operation is <em>independent</em> of other operations. This is very important when a database is handling concurrent data access. It should <em>appear</em> that the database is handling only one operation at a time. In order to accomplish this, the data that&#8217;s being updated must be <strong>locked</strong> out of being modified (and/or viewed) until the operation is complete.</p>
</div>
<div class="paragraph">
<p>Again, Couchbase is able to provide this guarantee at the single document level.</p>
</div>
<div class="paragraph">
<p>There are two types of locks that you can do in Couchbase: pessimistic locking and optimistic locking.</p>
</div>
<div class="sect2">
<h3 id="_optimistic_locking">Optimistic locking</h3>
<div class="paragraph">
<p>"Optimistic" locking hinges on a value in Couchbase called CAS (check-and-set). Every document has a CAS value, which is just a number. Every time that document changes, it gets a new CAS number. When you attempt to update a document, you pass a CAS number as part of the operation. If the CAS numbers match, Couchbase allows the operation. If not, the operation is not allowed, and Couchbase returns an error returned instead.</p>
</div>
<div class="paragraph">
<p>As an example, let&#8217;s suppose there are two processes: A and B. A and B both make a "get" request to Couchbase to fetch a document. Couchbase returns the document, along with a CAS value. Then, A and B both send a "set" request to Couchbase, passing along the CAS value they previously received. Processing will occur on one of them first, let&#8217;s say it&#8217;s A. When it&#8217;s B&#8217;s turn, the CAS value of the document has already changed, and so the operation fails.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s an example in .NET. Let&#8217;s suppose we&#8217;re working on a mobile game, and we want to keep track of a player&#8217;s Sword Level. The higher the level, the more damage it does. In this example, A is trying to upgrade to level 2 and B is trying to upgrade to level 3.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight decode:true"><code class="language-C#" data-lang="C#">// create initial document
bucket.Upsert("myweapon", new {offenseLevel = 1, name = "Excalibur"});

// document is retrieved by two different applications (A and B)
var weaponAResult = bucket.Get&lt;dynamic&gt;("myweapon");
var weaponA = weaponAResult.Value;
var weaponBResult = bucket.Get&lt;dynamic&gt;("myweapon");
var weaponB = weaponBResult.Value;
// at this point, CAS values should be the same
if (weaponAResult.Cas == weaponBResult.Cas)
    Console.WriteLine("CAS values are currently the same!");

// A makes a change
Console.WriteLine("'A' is updating the document");
weaponA.offenseLevel = 2;
IOperationResult aResult = bucket.Replace("myweapon", weaponA, weaponAResult.Cas);
if (aResult.Success)
    Console.WriteLine($"Change by 'A' was successful. New CAS value: {aResult.Cas}");

// B tries to make a change too
Console.WriteLine($"'B' is (attempting to) update the same document using old CAS value: {weaponBResult.Cas}");
weaponB.offenseLevel = 3;
IOperationResult bResult = bucket.Replace("myweapon", weaponB, weaponBResult.Cas);
if (!bResult.Success)
    Console.WriteLine($"Change by B failed: {bResult.Exception.Message}");</code></pre>
</div>
</div>
<div class="paragraph">
<p>At the end of this process, B fails, and the player&#8217;s sword stays at level 2. If you want B to succeed, then one solution is to re-fetch the document, get the latest CAS value, and try again.</p>
</div>
<div class="paragraph">
<p>Of course, that solution could fail again. And again. But this is why it&#8217;s called "optimistic". It assumes that the document is not going to be under heavy contention, and it will eventually succeed.</p>
</div>
</div>
<div class="sect2">
<h3 id="_pessimistic_locking">Pessimistic locking</h3>
<div class="paragraph">
<p>If you know that a document will be under heavy contention, and that it&#8217;s mostly likely to keep failing, then you might want to use pessimistic locking instead.</p>
</div>
<div class="paragraph">
<p>There is an atomic operation available in Couchbase called "GetAndLock". This operation returns the document and a CAS value. At this point, the document is considered "locked". No more locks can be made on it by other processes, and only the CAS value can unlock the document.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s a C# example of a pessimistic lock in action:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight decode:true"><code class="language-C#" data-lang="C#">// create initial document
bucket.Upsert("myshield", new { defenseLevel = 1, name = "Mirror Shield" });

// document is retrieved and locked by A
var shieldAResult = bucket.GetAndLock&lt;dynamic&gt;("myshield",TimeSpan.FromMilliseconds(30000));
var shieldA = shieldAResult.Value;
// B attempts to get and lock it as well
var shieldBResult = bucket.GetAndLock&lt;dynamic&gt;("myshield", TimeSpan.FromMilliseconds(30000));
if (!shieldBResult.Success)
{
    Console.WriteLine("B couldn't establish a lock, trying a plain Get");
    shieldBResult = bucket.Get&lt;dynamic&gt;("myshield");
}

// B tries to make a change, despite not having a lock
Console.WriteLine("'B' is updating the document");
var shieldB = shieldBResult.Value;
shieldB.defenseLevel = 3;
IOperationResult bResult = bucket.Replace("myshield", shieldB);
if (!bResult.Success)
{
    Console.WriteLine($"B was unable to make a change: {bResult.Message}");
    Console.WriteLine();
}

// A can make the change, but MUST use the CAS value
shieldA.defenseLevel = 2;
IOperationResult aResult = bucket.Replace("myshield", shieldA);
if (!aResult.Success)
{
    Console.WriteLine($"A tried to make a change, but forgot to use a CAS value: {aResult.Message}");
    Console.WriteLine();
    Console.WriteLine("Trying again with CAS this time");
    aResult = bucket.Replace("myshield", shieldA, shieldAResult.Cas);
    if(aResult.Success)
        Console.WriteLine("Success!");
}

// now, the document is unlocked
// so B can try again
bResult = bucket.Replace("myshield", shieldB);
if (bResult.Success)
    Console.WriteLine($"B was able to make a change.");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Further, when using GetAndLock, you must set a timeout period. After the timeout period, Couchbase releases the lock automatically. Here&#8217;s an example of the timeout in action.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight decode:true"><code class="language-C#" data-lang="C#">bucket.Upsert("mymagic", new { magicLevel = 1, name = "Fire Magic" });

// alternatively, if A never gets around to releasing the lock
// then the lock will automatically be released after a certain time
var magicAResult = bucket.GetAndLock&lt;dynamic&gt;("mymagic", TimeSpan.FromMilliseconds(5000));
if(magicAResult.Success)
    Console.WriteLine("Got a lock on 'mymagic'");
// try to get a new lock every second
for (var i = 0; i &lt; 10; i++)
{
    var magicBResult = bucket.GetAndLock&lt;dynamic&gt;("mymagic", TimeSpan.FromMilliseconds(5000));
    if (magicBResult.Success)
    {
        Console.WriteLine("Got a new lock on 'mymagic'!");
        bucket.Unlock("mymagic", magicBResult.Cas); // unlock it right away
        break;
    } else {
        Console.WriteLine("'mymagic' document is still locked.");
    }

    Thread.Sleep(1000);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When running this example, the following output would occur:</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="http://blog.couchbase.com/wp-content/uploads/2018/04/10502-pessimistic-lock-time-out.png" alt="Pessimistic lock time out"></span></p>
</div>
<div class="paragraph">
<p>Using these locks, you can obtain isolation of an individual document, to make sure that changes happen in the order that you expect.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_d_is_for_durability">D is for Durability</h2>
<div class="sectionbody">
<div class="paragraph">
<p>"Durability" traditionally means that when an operation completes successfully, that the disk stores the changes made by the operation. In a distributed database, durability can mean that the disk and/or the other nodes in the system store the changes. Ultimately, to a developer, it means that even if a system failure occurs, the change still takes place.</p>
</div>
<div class="paragraph">
<p>Couchbase has a "memory-first" architecture. This means that the results of write operations are first written to memory, and then put into a queue to be asynchronously written to disk or replicated to another node soon after. So, if an operation writes to memory, and the system shuts down immediately, then that operation is not durable. This is the default trade-off that Couchbase makes: speed over <a href="https://developer.couchbase.com/documentation/server/current/sdk/durability.html">durability</a>.</p>
</div>
<div class="paragraph">
<p>However, Couchbase allows you to override that default configuration and specify a stronger level of durability. This will swing the pendulum away from performance and towards the safety of ACID properties, but sometimes it may be necessary.</p>
</div>
<div class="paragraph">
<p>The default behavior is that writing the document to memory is considered a success. Couchbase will still persist and replicate according to your Couchbase cluster configuration, but the SDK will not check the durability.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight decode:true"><code class="language-C#" data-lang="C#">// default memory-first
var result1 = bucket.Upsert("memory-first", new {twitter = "@mgroves"});
if(result1.Success)
    Console.WriteLine("Success");</code></pre>
</div>
</div>
<div class="paragraph">
<p>I can specify the number of nodes to replicate to that I consider to be a successfully durable operation by using <code>ReplicateTo</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight decode:true"><code class="language-C#" data-lang="C#">// replicate
var result2 = bucket.Upsert("persist-to-1", new { email = "matthew.groves@couchbase.com" }, ReplicateTo.One);
if (result2.Success)
    Console.WriteLine("This will also fail if I only have 1 node");</code></pre>
</div>
</div>
<div class="paragraph">
<p>And I can also specify a combination of persistence to other nodes and replication to other nodes that I consider to be durable "enough" by using <code>PersistTo</code> as well:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight decode:true"><code class="language-C#" data-lang="C#">// persist and replicate
var result3 = bucket.Upsert("persist-to-1-replicate-to-1", new { site = "blog.couchbase.com" }, ReplicateTo.One, PersistTo.One);
if (result3.Success)
    Console.WriteLine("This will also fail if I only have 1 node");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that if the durability requirements <em>fail</em>, then Couchbase may still save the document and eventually distribute it across the cluster. All we know is that it didn&#8217;t succeed as far as the SDK knows. You can choose to act on this information to introduce more safety into your application.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_final_notes">Final Notes</h2>
<div class="sectionbody">
<div class="paragraph">
<p>It&#8217;s important to note that even with all these primitives, there&#8217;s no way to get the same kind of total safety that a non-distributed database can offer will full ACID properties. But you get a different kind of safety: if a single non-distributed database goes down, then your application is going to stop working altogether.</p>
</div>
<div class="paragraph">
<p>Make sure you are using a distributed database for the right use case and/or in concert with a traditional relational database. Then you can get the performance, scalability, and flexibility of NoSQL when you need it and the safety of relational when you need it. You can leverage all the primitives to provide some of the aspects of ACID properties when you need them.</p>
</div>
<div class="paragraph">
<p>In the next post, we&#8217;ll look at one way you might leverage these ACID properties and primitives to create a kind of "NoSQL transaction".</p>
</div>
<div class="paragraph">
<p>If you have any questions, be sure to check out the <a href="https://forums.couchbase.com/">Couchbase Forums</a>. You can find the same code used in this blog post <a href="//">on Github</a>.</p>
</div>
</div>
</div>
